(function(){"use strict";var W={ui8:"ui8",ui16:"ui16",ui32:"ui32",f32:"f32",eid:"eid"},Ot={i8:"Int8",ui8:"Uint8",ui8c:"Uint8Clamped",i16:"Int16",ui16:"Uint16",i32:"Int32",ui32:"Uint32",eid:"Uint32",f32:"Float32",f64:"Float64"},Q={i8:Int8Array,ui8:Uint8Array,ui8c:Uint8ClampedArray,i16:Int16Array,ui16:Uint16Array,i32:Int32Array,ui32:Uint32Array,f32:Float32Array,f64:Float64Array,eid:Uint32Array},Pt={uint8:2**8,uint16:2**16},se=t=>e=>Math.ceil(e/t)*t,re=se(4),oe=Symbol("storeRef"),vt=Symbol("storeSize"),ie=Symbol("storeMaps"),H=Symbol("storeFlattened"),ot=Symbol("storeBase"),ce=Symbol("storeType"),Dt=Symbol("storeArrayElementCounts"),it=Symbol("storeSubarrays"),_t=Symbol("subarrayCursors"),ae=Symbol("subarray"),dt=Symbol("parentArray"),jt=Symbol("tagStore"),Lt=Symbol("indexType"),Ut=Symbol("indexBytes"),Bt=Symbol("isEidType"),j={},ue=(t,e)=>{if(ArrayBuffer.isView(t))t[e]=t.slice(0);else{const n=t[dt].slice(0);t[e]=t.map((o,i)=>{const{length:r}=t[i],s=r*i,c=s+r;return n.subarray(s,c)})}},ye=(t,e)=>{t[H]&&t[H].forEach(n=>{ArrayBuffer.isView(n)?n[e]=0:n[e].fill(0)})},fe=(t,e)=>{const n=e*Q[t].BYTES_PER_ELEMENT,o=new ArrayBuffer(n),i=new Q[t](o);return i[Bt]=t===W.eid,i},le=(t,e,n)=>{const o=t[vt],i=Array(o).fill(0);i[ce]=e,i[Bt]=e===W.eid;const r=t[_t],s=n<=Pt.uint8?W.ui8:n<=Pt.uint16?W.ui16:W.ui32;if(!n)throw new Error("bitECS - Must define component array length");if(!Q[e])throw new Error(`bitECS - Invalid component array property type ${e}`);if(!t[it][e]){const u=t[Dt][e],l=new Q[e](re(u*o));l[Lt]=Ot[s],l[Ut]=Q[s].BYTES_PER_ELEMENT,t[it][e]=l}const c=r[e],a=c+o*n;r[e]=a,i[dt]=t[it][e].subarray(c,a);for(let u=0;u<o;u++){const l=n*u,C=l+n;i[u]=i[dt].subarray(l,C),i[u][Lt]=Ot[s],i[u][Ut]=Q[s].BYTES_PER_ELEMENT,i[u][ae]=!0}return i},kt=t=>Array.isArray(t)&&typeof t[0]=="string"&&typeof t[1]=="number",me=(t,e)=>{const n=Symbol("store");if(!t||!Object.keys(t).length)return j[n]={[vt]:e,[jt]:!0,[ot]:()=>j[n]},j[n];t=JSON.parse(JSON.stringify(t));const o={},i=s=>{const c=Object.keys(s);for(const a of c)kt(s[a])?(o[s[a][0]]||(o[s[a][0]]=0),o[s[a][0]]+=s[a][1]):s[a]instanceof Object&&i(s[a])};i(t);const r={[vt]:e,[ie]:{},[it]:{},[oe]:n,[_t]:Object.keys(Q).reduce((s,c)=>({...s,[c]:0}),{}),[H]:[],[Dt]:o};if(t instanceof Object&&Object.keys(t).length){const s=(c,a)=>{if(typeof c[a]=="string")c[a]=fe(c[a],e),c[a][ot]=()=>j[n],r[H].push(c[a]);else if(kt(c[a])){const[u,l]=c[a];c[a]=le(r,u,l),c[a][ot]=()=>j[n],r[H].push(c[a])}else c[a]instanceof Object&&(c[a]=Object.keys(c[a]).reduce(s,c[a]));return c};return j[n]=Object.assign(Object.keys(t).reduce(s,t),r),j[n][ot]=()=>j[n],j[n]}},J=()=>{const t=[],e=[];t.sort=function(s){const c=Array.prototype.sort.call(this,s);for(let a=0;a<t.length;a++)e[t[a]]=a;return c};const n=s=>t[e[s]]===s;return{add:s=>{n(s)||(e[s]=t.push(s)-1)},remove:s=>{if(!n(s))return;const c=e[s],a=t.pop();a!==s&&(t[c]=a,e[a]=c)},has:n,sparse:e,dense:t,reset:()=>{t.length=0,e.length=0}}},U=Symbol("entityMasks"),ct=Symbol("entityComponents"),B=Symbol("entitySparseSet"),K=Symbol("entityArray"),ve=1e5,St=0,Qt=ve,pt=()=>Qt,w=[],de=.01,Se=de,pe=()=>St,be=new Map,bt=t=>{const e=t[Mt]?w.length?w.shift():St++:w.length>Math.round(Qt*Se)?w.shift():St++;if(e>t[It])throw new Error("bitECS - max entities reached");return t[B].add(e),be.set(e,t),t[ht].forEach(n=>{Et(t,n,e)&&At(n,e)}),t[ct].set(e,new Set),e},at=(t,e)=>{if(t[B].has(e)){t[ut].forEach(n=>{Vt(t,n,e)}),t[Mt]||w.push(e),t[B].remove(e),t[ct].delete(e),t[Gt].delete(t[xt].get(e)),t[xt].delete(e);for(let n=0;n<t[U].length;n++)t[U][n][e]=0}},Ht=(t,e)=>t[B].has(e),he=Symbol("$modifier"),ut=Symbol("queries"),ht=Symbol("notQueries"),Ee=Symbol("queryAny"),Ae=Symbol("queryAll"),ge=Symbol("queryNone"),yt=Symbol("queryMap"),tt=Symbol("$dirtyQueries"),Yt=Symbol("queryComponents"),Ie=(t,e)=>{const n=[],o=[],i=[];e[Yt].forEach(y=>{if(typeof y=="function"&&y[he]){const[v,G]=y();t[L].has(v)||gt(t,v),G==="not"&&o.push(v),G==="changed"&&(i.push(v),n.push(v))}else t[L].has(y)||gt(t,y),n.push(y)});const r=y=>t[L].get(y),s=n.concat(o).map(r),c=J(),a=[],u=[],l=J(),C=J(),g=J(),D=s.map(y=>y.generationId).reduce((y,v)=>(y.includes(v)||y.push(v),y),[]),R=(y,v)=>(y[v.generationId]||(y[v.generationId]=0),y[v.generationId]|=v.bitflag,y),S=n.map(r).reduce(R,{}),d=o.map(r).reduce(R,{}),$=s.reduce(R,{}),_=n.filter(y=>!y[jt]).map(y=>Object.getOwnPropertySymbols(y).includes(H)?y[H]:[y]).reduce((y,v)=>y.concat(v),[]),x=Object.assign(c,{archetypes:a,changed:u,components:n,notComponents:o,changedComponents:i,allComponents:s,masks:S,notMasks:d,hasMasks:$,generations:D,flatProps:_,toRemove:l,entered:C,exited:g,shadows:[]});t[yt].set(e,x),t[ut].add(x),s.forEach(y=>{y.queries.add(x)}),o.length&&t[ht].add(x);for(let y=0;y<pe();y++){if(!t[B].has(y))continue;Et(t,x,y)&&At(x,y)}},xe=(t,e)=>{const n=Symbol(),o=t.flatProps[e];return ue(o,n),t.shadows[e]=o[n],o[n]},Me=(t,e)=>{e&&(t.changed=[]);const{flatProps:n,shadows:o}=t;for(let i=0;i<t.dense.length;i++){const r=t.dense[i];let s=!1;for(let c=0;c<n.length;c++){const a=n[c],u=o[c]||xe(t,c);if(ArrayBuffer.isView(a[r])){for(let l=0;l<a[r].length;l++)if(a[r][l]!==u[r][l]){s=!0;break}u[r].set(a[r])}else a[r]!==u[r]&&(s=!0,u[r]=a[r])}s&&t.changed.push(r)}return t.changed},M=(...t)=>{let e,n,o,i;if(Array.isArray(t[0])&&(e=t[0]),e===void 0||e[L]!==void 0)return s=>s?s[K]:e[K];const r=function(s,c=!0){s[yt].has(r)||Ie(s,r);const a=s[yt].get(r);return Re(s),a.changedComponents.length?Me(a,c):a.dense};return r[Yt]=e,r[Ee]=n,r[Ae]=o,r[ge]=i,r},Et=(t,e,n)=>{const{masks:o,notMasks:i,generations:r}=e;for(let s=0;s<r.length;s++){const c=r[s],a=o[c],u=i[c],l=t[U][c][n];if(u&&(l&u)!==0||a&&(l&a)!==a)return!1}return!0},At=(t,e)=>{t.toRemove.remove(e),t.entered.add(e),t.add(e)},Te=t=>{for(let e=t.toRemove.dense.length-1;e>=0;e--){const n=t.toRemove.dense[e];t.toRemove.remove(n),t.remove(n)}},Re=t=>{t[tt].size&&(t[tt].forEach(Te),t[tt].clear())},Vt=(t,e,n)=>{!e.has(n)||e.toRemove.has(n)||(e.toRemove.add(n),t[tt].add(e),e.exited.add(n))},L=Symbol("componentMap"),E=(t,e)=>{const n=me(t,pt());return t&&Object.keys(t).length,n},Ne=t=>{t[et]*=2,t[et]>=2**31&&(t[et]=1,t[U].push(new Uint32Array(t[It])))},gt=(t,e)=>{if(!e)throw new Error("bitECS - Cannot register null or undefined component");const n=new Set,o=new Set,i=new Set;t[ut].forEach(r=>{r.allComponents.includes(e)&&n.add(r)}),t[L].set(e,{generationId:t[U].length-1,bitflag:t[et],store:e,queries:n,notQueries:o,changedQueries:i}),Ne(t)},F=(t,e,n)=>{const o=t[L].get(e);if(!o)return!1;const{generationId:i,bitflag:r}=o;return(t[U][i][n]&r)===r},p=(t,e,n,o=!1)=>{if(n===void 0)throw new Error("bitECS - entity is undefined.");if(!t[B].has(n))throw new Error("bitECS - entity does not exist in the world.");if(t[L].has(e)||gt(t,e),F(t,e,n))return;const i=t[L].get(e),{generationId:r,bitflag:s,queries:c,notQueries:a}=i;t[U][r][n]|=s,c.forEach(u=>{u.toRemove.remove(n);const l=Et(t,u,n);l&&(u.exited.remove(n),At(u,n)),l||(u.entered.remove(n),Vt(t,u,n))}),t[ct].get(n).add(e),o&&ye(e,n)},It=Symbol("size"),et=Symbol("bitflag"),Ce=Symbol("archetypes"),Gt=Symbol("localEntities"),xt=Symbol("localEntityLookup"),Mt=Symbol("manualEntityRecycling"),$e=(...t)=>{const e=typeof t[0]=="object"?t[0]:{},n=typeof t[0]=="number"?t[0]:typeof t[1]=="number"?t[1]:pt();return Oe(e,n),e},Oe=(t,e=pt())=>(t[It]=e,t[K]&&t[K].forEach(n=>at(t,n)),t[U]=[new Uint32Array(e)],t[ct]=new Map,t[Ce]=[],t[B]=J(),t[K]=t[B].dense,t[et]=1,t[L]=new Map,t[yt]=new Map,t[ut]=new Set,t[ht]=new Set,t[tt]=new Set,t[Gt]=new Map,t[xt]=new Map,t[Mt]=!1,t),X=t=>(e,...n)=>(t(e,...n),e),m=W;const Tt=300,Wt=1920,Ft=1080,Pe=2,ft=0,O=1,De=()=>{const t=$e();return t.time=0,t.delta=0,t.movements=null,Ht(t,ft)||bt(t),t};var P=(t=>(t[t.AffectedByGravity=1]="AffectedByGravity",t[t.Collision=2]="Collision",t[t.Destructible=4]="Destructible",t[t.HasGravity=8]="HasGravity",t[t.HasLifetime=16]="HasLifetime",t[t.Position=32]="Position",t[t.Projectile=64]="Projectile",t[t.Velocity=128]="Velocity",t[t.Wormhole=256]="Wormhole",t[t.Active=512]="Active",t))(P||{}),z=(t=>(t[t.ACTIVE=0]="ACTIVE",t[t.INITIALIZE=1]="INITIALIZE",t[t.INITIALIZE_DONE=2]="INITIALIZE_DONE",t[t.SIMULATE=3]="SIMULATE",t[t.SIMULATE_DONE=4]="SIMULATE_DONE",t))(z||{});const Rt=E(),N=E({radius:m.ui16}),nt=E(),Y=E({strength:m.f32,radius:m.f32,falloffType:m.ui8});var st=(t=>(t[t.INVERSE_SQUARE=0]="INVERSE_SQUARE",t[t.LINEAR=1]="LINEAR",t[t.CONSTANT=2]="CONSTANT",t))(st||{});const q=E({createdAt:m.ui32}),rt=E({type:m.ui8,cloneOf:m.eid}),_e=E(),f=E({x:m.f32,y:m.f32}),A=E({parent:m.eid,lastCollisionTarget:m.eid}),T=E({x:m.f32,y:m.f32}),Z=E({teleportTarget:m.eid,exitType:m.ui8});var Nt=(t=>(t[t.PAIRED=0]="PAIRED",t[t.RANDOM=1]="RANDOM",t[t.PAIRED_GIANT=2]="PAIRED_GIANT",t))(Nt||{});E({pooledProjectile:m.eid});const h=E(),je=30,Xt=0-Tt,Le=Wt+Tt,Ue=Ft+Tt,Be=M([f,T,h]),ke=M([q,h]),Qe=(t=()=>{})=>X(e=>{const n=Be(e);for(const i of n){const r=f.x[i],s=f.y[i];r<Le&&r>Xt&&s<Ue&&s>Xt||t(i)}const o=ke(e);for(const i of o)e.time-q.createdAt[i]>=je*1e3&&t(i);return e}),zt=(t,e)=>Math.floor(Math.random()*(e-t+1)+t),k=t=>N.radius[t],V=t=>({x:f.x[t],y:f.y[t]}),Ct=(t,e,n)=>{if(typeof e.x<"u"){const o=e;f.x[t]=o.x,f.y[t]=o.y}else f.x[t]=e,f.y[t]=n},He=M([N,f,h]),qt=t=>He(t);M([N,f,nt,h]);const Ye=t=>qt(t).map(e=>({x:f.x[e],y:f.y[e],radius:N.radius[e],eid:e}));M([_e,h]);function Ve(t,e,n,o,i){const r=[],s=Array.isArray(i)?i:Ye(i);for(const c of n){let a=0,u=!1;for(;a++<1e3&&!u;){const l=zt(c,t-c),C=zt(c,e-c),g={x:l,y:C,radius:c,eid:-1};[...s,...r].some(R=>{const S=l-R.x,d=C-R.y,$=S*S+d*d,_=o(c,R.radius),I=_*_;return $<I})||(r.push(g),u=!0)}u||(console.log(`Failed to place object with radius ${c} after 1000 attempts.`),r.push({x:10,y:10,radius:c,eid:-1}))}return r}const Ge=(t,e,n,o,i,r)=>{const s=o-t,c=i-e,a=s*s+c*c,u=n+r;return a<u*u},We=(t,e)=>{const{x:n,y:o}=V(t),i=k(t),{x:r,y:s}=V(e),c=k(e);return Ge(n,o,i,r,s,c)},Fe=M([f,N,A,h]),Xe=M([f,N,h]),ze=()=>X(t=>{const e=Fe(t),n=Xe(t);for(let o=0;o<e.length;o++){const i=e[o];for(let r=0;r<n.length;r++){const s=n[r];i!==s&&We(i,s)&&(A.lastCollisionTarget[i]=s)}}return t}),qe=M([A,f,N,h]),Ze=(t=()=>!0)=>X(e=>{if(!e.movements)return e;const n=qe(e);for(const o of n){const i=A.parent[o],r=A.lastCollisionTarget[o];if(r!==ft){if(F(e,A,r)){A.lastCollisionTarget[o]=ft;continue}if(F(e,nt,r)){t(o,r,!0,e.time)&&at(e,r),e.movements[i].destroyedTarget=r;continue}if(F(e,Z,r)){Je(o,r,e),A.lastCollisionTarget[o]=ft;continue}t(o,r,!1,e.time)}}return e}),Je=(t,e,n)=>{const o=Z.exitType[e];if(o===Nt.RANDOM){const[I]=Ve(Wt,Ft,[k(t)],(x,y)=>x+y+5,n);Ct(t,I);return}const i=Z.teleportTarget[e],r=V(e),s=V(i),c=k(i),a=V(t);if(o===Nt.PAIRED_GIANT){const I=a.x-r.x,x=a.y-r.y,v=Math.atan2(x,I)+Math.PI,G=1.5,lt=s.x+Math.cos(v)*(c+G),mt=s.y+Math.sin(v)*(c+G);Ct(t,lt,mt);return}const u=a.x-r.x,l=a.y-r.y,C=-u,g=-l,D=Math.hypot(C,g),R=C/D,S=g/D,d=1.5,$=s.x+R*(c+d),_=s.y+S*(c+d);Ct(t,$,_)},Zt=1e-4,Ke=M([Y,f,h]),we=M([Rt,T,f,h]),tn=()=>X(t=>{const e=t.delta,n=Ke(t),o=we(t);for(const i of o){let r=0,s=0;const c=f.x[i],a=f.y[i];for(const u of n){const l=f.x[u],C=f.y[u],g=l-c,D=C-a,R=g*g+D*D+Zt,S=Math.sqrt(R),d=Y.strength[u],$=Y.radius[u]||0,_=Y.falloffType[u]??st.INVERSE_SQUARE;if($>0&&S>$)continue;let I=0;switch(_){case st.CONSTANT:I=d;break;case st.LINEAR:if($>0){const v=1-S/$;I=d*Math.max(0,v)}else I=d/(S+Zt);break;case st.INVERSE_SQUARE:default:I=d/R;break}const x=g/S*I,y=D/S*I;r+=x,s+=y}T.x[i]+=r*e,T.y[i]+=s*e}return t}),en=E({strength:m.f32,innerRadius:m.f32,length:m.f32,tanHalfSpread:m.f32,spreadRad:m.f32,dirX:m.f32,dirY:m.f32,perpX:m.f32,perpY:m.f32,corePow:m.f32,endFadeFrac:m.f32,outerFadeBias:m.f32,deflectAngleRad:m.f32}),nn=E();M([en,f,h]),M([nn,T,f,h]);const Jt=1/300,sn=M([f,T,h]),rn=()=>X(t=>{const n=t.delta,o=sn(t);for(const i of o){const r=T.x[i],s=T.y[i],c=r*n*Jt,a=s*n*Jt,u=f.x[i]+c,l=f.y[i]+a;f.x[i]=u,f.y[i]=l}return t}),on=M([f,A,h]),cn=()=>X(t=>{const e=t,n=on(e);n.length&&(e.movements=e.movements||{});for(const o of n){const i=A.parent[o];e.movements[i]=e.movements[i]||{id:o,movementTrace:[],destroyedTarget:null};const{x:r,y:s}=V(o);e.movements[i].movementTrace.push({x:r,y:s})}return e}),an=(t,e)=>{const n=t.x-e.x,o=t.y-e.y;return n*n+o*o},un=t=>qt(t).map(e=>({eid:e,breaks:F(t,nt,e),x:f.x[e],y:f.y[e],r:k(e),r2:Math.pow(k(e),2)})),yn=(t,e,n)=>{const o=n.power*2,i=n.angle*(Math.PI/180),r=N.radius[t]+Pe;f.x[e]=f.x[t]+Math.cos(i)*r,f.y[e]=f.y[t]+Math.sin(i)*r,T.x[e]=Math.cos(i)*o,T.y[e]=Math.sin(i)*o},fn=(t,e)=>{const n=new Map,o=t.count;N.radius.set(t.radius.subarray(0,o),O),Y.strength.set(t.strength.subarray(0,o),O),Y.falloffType.set(t.falloffType.subarray(0,o),O),q.createdAt.set(t.createdAt.subarray(0,o),O),f.x.set(t.posX.subarray(0,o),O),f.y.set(t.posY.subarray(0,o),O),A.parent.set(t.parent.subarray(0,o),O),A.lastCollisionTarget.set(t.lastCollisionTarget.subarray(0,o),O),T.x.set(t.velX.subarray(0,o),O),T.y.set(t.velY.subarray(0,o),O),Z.teleportTarget.set(t.teleportTarget.subarray(0,o),O),Z.exitType.set(t.exitType.subarray(0,o),O);for(let i=0;i<o;i++){const r=t.eid[i],s=bt(e);n.set(r,s),p(e,rt,s),rt.type[s]=t.type[i],rt.cloneOf[s]=r;const c=t.componentTags[i];c&P.AffectedByGravity&&p(e,Rt,s),c&P.Destructible&&p(e,nt,s),c&P.Collision&&p(e,N,s),c&P.HasGravity&&p(e,Y,s),c&P.HasLifetime&&p(e,q,s),c&P.Position&&p(e,f,s),c&P.Projectile&&p(e,A,s),c&P.Velocity&&p(e,T,s),c&P.Wormhole&&p(e,Z,s),c&P.Active&&p(e,h,s)}return n},ln=1e4,Kt=8,b=De();let wt=new Map,te=[],ee=()=>{};self.onmessage=t=>{const{type:e,snapshot:n,turnInput:o}=t.data;switch(e){case z.INITIALIZE:wt=fn(n,b),te=un(b),ee=dn(),self.postMessage({type:z.INITIALIZE_DONE});break;case z.SIMULATE:{const i={...o,playerId:wt.get(o.playerId)},r=mn(i,te,ee),s={...r,hitsEid:rt.cloneOf[r.hitsEid],closestDestructible:rt.cloneOf[r.closestDestructible]};self.postMessage({type:z.SIMULATE_DONE,result:s});break}}},self.postMessage({type:z.ACTIVE});const mn=(t,e,n)=>{const{playerId:o}=t,i=e.filter(S=>S.eid!==o);let r=0,s=0,c=null,a=1/0,u={x:0,y:0};const l=vn(t);for(let S=0;S<ln&&(n(b,S,Kt),!!Ht(b,l));S+=Kt){for(const d of i){const $=V(l),{x:_,y:I}=$,x=k(l),{x:y,y:v}=d,G=k(d.eid),lt=y-_,mt=v-I,$t=lt*lt+mt*mt,ne=x+G;if($t<ne*ne){s=d.eid,c=S,d.breaks&&(r=d.eid);break}d.breaks&&$t<a&&(a=$t,r=d.eid,u=$)}if(s){at(b,l);break}}const C=s===r,g=b.movements&&[...b.movements[o].movementTrace]||[];b.movements=null;const D={angle:t.angle,power:t.power},R=!!(s&&F(b,nt,s));return{hitsEid:s,hitsSelf:s===o,destructible:R,willHit:C,closestDestructible:r,closestPoint:u,closestDist2:a,shotDist2:an(g[0],g[g.length-1]),collisionT:c,input:D,shotTrail:g}},vn=t=>{const e=bt(b),{playerId:n}=t;return p(b,f,e),p(b,T,e),p(b,N,e),p(b,A,e),p(b,Rt,e),p(b,q,e),p(b,h,e),N.radius[e]=N.radius[t.playerId]/8,A.parent[e]=t.playerId,q.createdAt[e]=0,yn(n,e,t),e},dn=()=>{const t=rn(),e=cn(),n=tn(),o=ze(),i=Ze(()=>!1),r=Qe(s=>at(b,s));return(s,c,a)=>{s.time=c,s.delta=a,t(s),e(s),n(s),o(s),i(s),r(s)}}})();
