(function(){"use strict";var W={ui8:"ui8",ui16:"ui16",ui32:"ui32",f32:"f32",eid:"eid"},Ot={i8:"Int8",ui8:"Uint8",ui8c:"Uint8Clamped",i16:"Int16",ui16:"Uint16",i32:"Int32",ui32:"Uint32",eid:"Uint32",f32:"Float32",f64:"Float64"},Q={i8:Int8Array,ui8:Uint8Array,ui8c:Uint8ClampedArray,i16:Int16Array,ui16:Uint16Array,i32:Int32Array,ui32:Uint32Array,f32:Float32Array,f64:Float64Array,eid:Uint32Array},Dt={uint8:2**8,uint16:2**16},se=t=>e=>Math.ceil(e/t)*t,re=se(4),oe=Symbol("storeRef"),vt=Symbol("storeSize"),ie=Symbol("storeMaps"),V=Symbol("storeFlattened"),ot=Symbol("storeBase"),ce=Symbol("storeType"),Pt=Symbol("storeArrayElementCounts"),it=Symbol("storeSubarrays"),_t=Symbol("subarrayCursors"),ae=Symbol("subarray"),St=Symbol("parentArray"),jt=Symbol("tagStore"),Lt=Symbol("indexType"),Ut=Symbol("indexBytes"),kt=Symbol("isEidType"),j={},ue=(t,e)=>{if(ArrayBuffer.isView(t))t[e]=t.slice(0);else{const n=t[St].slice(0);t[e]=t.map((o,i)=>{const{length:r}=t[i],s=r*i,c=s+r;return n.subarray(s,c)})}},ye=(t,e)=>{t[V]&&t[V].forEach(n=>{ArrayBuffer.isView(n)?n[e]=0:n[e].fill(0)})},fe=(t,e)=>{const n=e*Q[t].BYTES_PER_ELEMENT,o=new ArrayBuffer(n),i=new Q[t](o);return i[kt]=t===W.eid,i},le=(t,e,n)=>{const o=t[vt],i=Array(o).fill(0);i[ce]=e,i[kt]=e===W.eid;const r=t[_t],s=n<=Dt.uint8?W.ui8:n<=Dt.uint16?W.ui16:W.ui32;if(!n)throw new Error("bitECS - Must define component array length");if(!Q[e])throw new Error(`bitECS - Invalid component array property type ${e}`);if(!t[it][e]){const u=t[Pt][e],l=new Q[e](re(u*o));l[Lt]=Ot[s],l[Ut]=Q[s].BYTES_PER_ELEMENT,t[it][e]=l}const c=r[e],a=c+o*n;r[e]=a,i[St]=t[it][e].subarray(c,a);for(let u=0;u<o;u++){const l=n*u,T=l+n;i[u]=i[St].subarray(l,T),i[u][Lt]=Ot[s],i[u][Ut]=Q[s].BYTES_PER_ELEMENT,i[u][ae]=!0}return i},Bt=t=>Array.isArray(t)&&typeof t[0]=="string"&&typeof t[1]=="number",me=(t,e)=>{const n=Symbol("store");if(!t||!Object.keys(t).length)return j[n]={[vt]:e,[jt]:!0,[ot]:()=>j[n]},j[n];t=JSON.parse(JSON.stringify(t));const o={},i=s=>{const c=Object.keys(s);for(const a of c)Bt(s[a])?(o[s[a][0]]||(o[s[a][0]]=0),o[s[a][0]]+=s[a][1]):s[a]instanceof Object&&i(s[a])};i(t);const r={[vt]:e,[ie]:{},[it]:{},[oe]:n,[_t]:Object.keys(Q).reduce((s,c)=>({...s,[c]:0}),{}),[V]:[],[Pt]:o};if(t instanceof Object&&Object.keys(t).length){const s=(c,a)=>{if(typeof c[a]=="string")c[a]=fe(c[a],e),c[a][ot]=()=>j[n],r[V].push(c[a]);else if(Bt(c[a])){const[u,l]=c[a];c[a]=le(r,u,l),c[a][ot]=()=>j[n],r[V].push(c[a])}else c[a]instanceof Object&&(c[a]=Object.keys(c[a]).reduce(s,c[a]));return c};return j[n]=Object.assign(Object.keys(t).reduce(s,t),r),j[n][ot]=()=>j[n],j[n]}},J=()=>{const t=[],e=[];t.sort=function(s){const c=Array.prototype.sort.call(this,s);for(let a=0;a<t.length;a++)e[t[a]]=a;return c};const n=s=>t[e[s]]===s;return{add:s=>{n(s)||(e[s]=t.push(s)-1)},remove:s=>{if(!n(s))return;const c=e[s],a=t.pop();a!==s&&(t[c]=a,e[a]=c)},has:n,sparse:e,dense:t,reset:()=>{t.length=0,e.length=0}}},U=Symbol("entityMasks"),ct=Symbol("entityComponents"),k=Symbol("entitySparseSet"),K=Symbol("entityArray"),ve=1e5,bt=0,Qt=ve,pt=()=>Qt,w=[],Se=.01,be=Se,pe=()=>bt,de=new Map,dt=t=>{const e=t[Mt]?w.length?w.shift():bt++:w.length>Math.round(Qt*be)?w.shift():bt++;if(e>t[It])throw new Error("bitECS - max entities reached");return t[k].add(e),de.set(e,t),t[ht].forEach(n=>{Et(t,n,e)&&At(n,e)}),t[ct].set(e,new Set),e},at=(t,e)=>{if(t[k].has(e)){t[ut].forEach(n=>{Ht(t,n,e)}),t[Mt]||w.push(e),t[k].remove(e),t[ct].delete(e),t[Gt].delete(t[xt].get(e)),t[xt].delete(e);for(let n=0;n<t[U].length;n++)t[U][n][e]=0}},Vt=(t,e)=>t[k].has(e),he=Symbol("$modifier"),ut=Symbol("queries"),ht=Symbol("notQueries"),Ee=Symbol("queryAny"),Ae=Symbol("queryAll"),ge=Symbol("queryNone"),yt=Symbol("queryMap"),tt=Symbol("$dirtyQueries"),Yt=Symbol("queryComponents"),Ie=(t,e)=>{const n=[],o=[],i=[];e[Yt].forEach(y=>{if(typeof y=="function"&&y[he]){const[m,G]=y();t[L].has(m)||gt(t,m),G==="not"&&o.push(m),G==="changed"&&(i.push(m),n.push(m))}else t[L].has(y)||gt(t,y),n.push(y)});const r=y=>t[L].get(y),s=n.concat(o).map(r),c=J(),a=[],u=[],l=J(),T=J(),E=J(),P=s.map(y=>y.generationId).reduce((y,m)=>(y.includes(m)||y.push(m),y),[]),I=(y,m)=>(y[m.generationId]||(y[m.generationId]=0),y[m.generationId]|=m.bitflag,y),S=n.map(r).reduce(I,{}),v=o.map(r).reduce(I,{}),R=s.reduce(I,{}),_=n.filter(y=>!y[jt]).map(y=>Object.getOwnPropertySymbols(y).includes(V)?y[V]:[y]).reduce((y,m)=>y.concat(m),[]),g=Object.assign(c,{archetypes:a,changed:u,components:n,notComponents:o,changedComponents:i,allComponents:s,masks:S,notMasks:v,hasMasks:R,generations:P,flatProps:_,toRemove:l,entered:T,exited:E,shadows:[]});t[yt].set(e,g),t[ut].add(g),s.forEach(y=>{y.queries.add(g)}),o.length&&t[ht].add(g);for(let y=0;y<pe();y++){if(!t[k].has(y))continue;Et(t,g,y)&&At(g,y)}},xe=(t,e)=>{const n=Symbol(),o=t.flatProps[e];return ue(o,n),t.shadows[e]=o[n],o[n]},Me=(t,e)=>{e&&(t.changed=[]);const{flatProps:n,shadows:o}=t;for(let i=0;i<t.dense.length;i++){const r=t.dense[i];let s=!1;for(let c=0;c<n.length;c++){const a=n[c],u=o[c]||xe(t,c);if(ArrayBuffer.isView(a[r])){for(let l=0;l<a[r].length;l++)if(a[r][l]!==u[r][l]){s=!0;break}u[r].set(a[r])}else a[r]!==u[r]&&(s=!0,u[r]=a[r])}s&&t.changed.push(r)}return t.changed},O=(...t)=>{let e,n,o,i;if(Array.isArray(t[0])&&(e=t[0]),e===void 0||e[L]!==void 0)return s=>s?s[K]:e[K];const r=function(s,c=!0){s[yt].has(r)||Ie(s,r);const a=s[yt].get(r);return Re(s),a.changedComponents.length?Me(a,c):a.dense};return r[Yt]=e,r[Ee]=n,r[Ae]=o,r[ge]=i,r},Et=(t,e,n)=>{const{masks:o,notMasks:i,generations:r}=e;for(let s=0;s<r.length;s++){const c=r[s],a=o[c],u=i[c],l=t[U][c][n];if(u&&(l&u)!==0||a&&(l&a)!==a)return!1}return!0},At=(t,e)=>{t.toRemove.remove(e),t.entered.add(e),t.add(e)},Te=t=>{for(let e=t.toRemove.dense.length-1;e>=0;e--){const n=t.toRemove.dense[e];t.toRemove.remove(n),t.remove(n)}},Re=t=>{t[tt].size&&(t[tt].forEach(Te),t[tt].clear())},Ht=(t,e,n)=>{!e.has(n)||e.toRemove.has(n)||(e.toRemove.add(n),t[tt].add(e),e.exited.add(n))},L=Symbol("componentMap"),N=(t,e)=>{const n=me(t,pt());return t&&Object.keys(t).length,n},Ne=t=>{t[et]*=2,t[et]>=2**31&&(t[et]=1,t[U].push(new Uint32Array(t[It])))},gt=(t,e)=>{if(!e)throw new Error("bitECS - Cannot register null or undefined component");const n=new Set,o=new Set,i=new Set;t[ut].forEach(r=>{r.allComponents.includes(e)&&n.add(r)}),t[L].set(e,{generationId:t[U].length-1,bitflag:t[et],store:e,queries:n,notQueries:o,changedQueries:i}),Ne(t)},z=(t,e,n)=>{const o=t[L].get(e);if(!o)return!1;const{generationId:i,bitflag:r}=o;return(t[U][i][n]&r)===r},b=(t,e,n,o=!1)=>{if(n===void 0)throw new Error("bitECS - entity is undefined.");if(!t[k].has(n))throw new Error("bitECS - entity does not exist in the world.");if(t[L].has(e)||gt(t,e),z(t,e,n))return;const i=t[L].get(e),{generationId:r,bitflag:s,queries:c,notQueries:a}=i;t[U][r][n]|=s,c.forEach(u=>{u.toRemove.remove(n);const l=Et(t,u,n);l&&(u.exited.remove(n),At(u,n)),l||(u.entered.remove(n),Ht(t,u,n))}),t[ct].get(n).add(e),o&&ye(e,n)},It=Symbol("size"),et=Symbol("bitflag"),Ce=Symbol("archetypes"),Gt=Symbol("localEntities"),xt=Symbol("localEntityLookup"),Mt=Symbol("manualEntityRecycling"),$e=(...t)=>{const e=typeof t[0]=="object"?t[0]:{},n=typeof t[0]=="number"?t[0]:typeof t[1]=="number"?t[1]:pt();return Oe(e,n),e},Oe=(t,e=pt())=>(t[It]=e,t[K]&&t[K].forEach(n=>at(t,n)),t[U]=[new Uint32Array(e)],t[ct]=new Map,t[Ce]=[],t[k]=J(),t[K]=t[k].dense,t[et]=1,t[L]=new Map,t[yt]=new Map,t[ut]=new Set,t[ht]=new Set,t[tt]=new Set,t[Gt]=new Map,t[xt]=new Map,t[Mt]=!1,t),X=t=>(e,...n)=>(t(e,...n),e),d=W;const Tt=300,Wt=1920,zt=1080,De=2,ft=0,C=1,Pe=()=>{const t=$e();return t.time=0,t.delta=0,t.movements=null,Vt(t,ft)||dt(t),t};var D=(t=>(t[t.AffectedByGravity=1]="AffectedByGravity",t[t.Collision=2]="Collision",t[t.Destructible=4]="Destructible",t[t.HasGravity=8]="HasGravity",t[t.HasLifetime=16]="HasLifetime",t[t.Position=32]="Position",t[t.Projectile=64]="Projectile",t[t.Velocity=128]="Velocity",t[t.Wormhole=256]="Wormhole",t[t.Active=512]="Active",t))(D||{}),q=(t=>(t[t.ACTIVE=0]="ACTIVE",t[t.INITIALIZE=1]="INITIALIZE",t[t.INITIALIZE_DONE=2]="INITIALIZE_DONE",t[t.SIMULATE=3]="SIMULATE",t[t.SIMULATE_DONE=4]="SIMULATE_DONE",t))(q||{});const Rt=N(),$=N({radius:d.ui16}),nt=N(),Y=N({strength:d.f32,radius:d.f32,falloffType:d.ui8});var st=(t=>(t[t.INVERSE_SQUARE=0]="INVERSE_SQUARE",t[t.LINEAR=1]="LINEAR",t[t.CONSTANT=2]="CONSTANT",t))(st||{});const F=N({createdAt:d.ui32}),rt=N({type:d.ui8,cloneOf:d.eid}),f=N({x:d.f32,y:d.f32}),h=N({parent:d.eid,lastCollisionTarget:d.eid}),x=N({x:d.f32,y:d.f32}),Z=N({teleportTarget:d.eid,exitType:d.ui8});var Nt=(t=>(t[t.PAIRED=0]="PAIRED",t[t.RANDOM=1]="RANDOM",t[t.PAIRED_GIANT=2]="PAIRED_GIANT",t))(Nt||{});N({pooledProjectile:d.eid});const M=N(),_e=30,Xt=0-Tt,je=Wt+Tt,Le=zt+Tt,Ue=O([f,x,M]),ke=O([F,M]),Be=(t=()=>{})=>X(e=>{const n=Ue(e);for(const i of n){const r=f.x[i],s=f.y[i];r<je&&r>Xt&&s<Le&&s>Xt||t(i)}const o=ke(e);for(const i of o)e.time-F.createdAt[i]>=_e*1e3&&t(i);return e}),qt=(t,e)=>Math.floor(Math.random()*(e-t+1)+t),B=t=>$.radius[t],H=t=>({x:f.x[t],y:f.y[t]}),Ct=(t,e,n)=>{if(typeof e.x<"u"){const o=e;f.x[t]=o.x,f.y[t]=o.y}else f.x[t]=e,f.y[t]=n},Qe=O([$,f,M]),Ft=t=>Qe(t);O([$,f,nt,M]);const Ve=t=>Ft(t).map(e=>({x:f.x[e],y:f.y[e],radius:$.radius[e],eid:e}));function Ye(t,e,n,o,i){const r=[],s=Array.isArray(i)?i:Ve(i);for(const c of n){let a=0,u=!1;for(;a++<1e3&&!u;){const l=qt(c,t-c),T=qt(c,e-c),E={x:l,y:T,radius:c,eid:-1};[...s,...r].some(I=>{const S=l-I.x,v=T-I.y,R=S*S+v*v,_=o(c,I.radius),A=_*_;return R<A})||(r.push(E),u=!0)}u||(console.log(`Failed to place object with radius ${c} after 1000 attempts.`),r.push({x:10,y:10,radius:c,eid:-1}))}return r}const He=(t,e,n,o,i,r)=>{const s=o-t,c=i-e,a=s*s+c*c,u=n+r;return a<u*u},Ge=(t,e)=>{const{x:n,y:o}=H(t),i=B(t),{x:r,y:s}=H(e),c=B(e);return He(n,o,i,r,s,c)},We=O([f,$,h,M]),ze=O([f,$,M]),Xe=()=>X(t=>{const e=We(t),n=ze(t);for(let o=0;o<e.length;o++){const i=e[o];for(let r=0;r<n.length;r++){const s=n[r];i!==s&&Ge(i,s)&&(h.lastCollisionTarget[i]=s)}}return t}),qe=O([h,f,$,M]),Fe=(t=()=>!0)=>X(e=>{if(!e.movements)return e;const n=qe(e);for(const o of n){const i=h.parent[o],r=h.lastCollisionTarget[o];if(r!==ft){if(z(e,h,r)){h.lastCollisionTarget[o]=ft;continue}if(z(e,nt,r)){t(o,r,!0,e.time)&&at(e,r),e.movements[i].destroyedTarget=r;continue}if(z(e,Z,r)){Ze(o,r,e),h.lastCollisionTarget[o]=ft;continue}t(o,r,!1,e.time)}}return e}),Ze=(t,e,n)=>{const o=Z.exitType[e];if(o===Nt.RANDOM){const[A]=Ye(Wt,zt,[B(t)],(g,y)=>g+y+5,n);Ct(t,A);return}const i=Z.teleportTarget[e],r=H(e),s=H(i),c=B(i),a=H(t);if(o===Nt.PAIRED_GIANT){const A=a.x-r.x,g=a.y-r.y,m=Math.atan2(g,A)+Math.PI,G=1.5,lt=s.x+Math.cos(m)*(c+G),mt=s.y+Math.sin(m)*(c+G);Ct(t,lt,mt);return}const u=a.x-r.x,l=a.y-r.y,T=-u,E=-l,P=Math.hypot(T,E),I=T/P,S=E/P,v=1.5,R=s.x+I*(c+v),_=s.y+S*(c+v);Ct(t,R,_)},Zt=1e-4,Je=O([Y,f,M]),Ke=O([Rt,x,f,M]),we=()=>X(t=>{const e=t.delta,n=Je(t),o=Ke(t);for(const i of o){let r=0,s=0;const c=f.x[i],a=f.y[i];for(const u of n){const l=f.x[u],T=f.y[u],E=l-c,P=T-a,I=E*E+P*P+Zt,S=Math.sqrt(I),v=Y.strength[u],R=Y.radius[u]||0,_=Y.falloffType[u]??st.INVERSE_SQUARE;if(R>0&&S>R)continue;let A=0;switch(_){case st.CONSTANT:A=v;break;case st.LINEAR:if(R>0){const m=1-S/R;A=v*Math.max(0,m)}else A=v/(S+Zt);break;case st.INVERSE_SQUARE:default:A=v/I;break}const g=E/S*A,y=P/S*A;r+=g,s+=y}x.x[i]+=r*e,x.y[i]+=s*e}return t}),Jt=1/300,tn=O([f,x,M]),en=()=>X(t=>{const n=t.delta,o=tn(t);for(const i of o){const r=x.x[i],s=x.y[i],c=r*n*Jt,a=s*n*Jt,u=f.x[i]+c,l=f.y[i]+a;f.x[i]=u,f.y[i]=l}return t}),nn=O([f,h,M]),sn=()=>X(t=>{const e=t,n=nn(e);n.length&&(e.movements=e.movements||{});for(const o of n){const i=h.parent[o];e.movements[i]=e.movements[i]||{id:o,movementTrace:[],destroyedTarget:null};const{x:r,y:s}=H(o);e.movements[i].movementTrace.push({x:r,y:s})}return e}),rn=(t,e)=>{const n=t.x-e.x,o=t.y-e.y;return n*n+o*o},on=t=>Ft(t).map(e=>({eid:e,breaks:z(t,nt,e),x:f.x[e],y:f.y[e],r:B(e),r2:Math.pow(B(e),2)})),cn=(t,e,n)=>{const o=n.power*2,i=n.angle*(Math.PI/180),r=$.radius[t]+De;f.x[e]=f.x[t]+Math.cos(i)*r,f.y[e]=f.y[t]+Math.sin(i)*r,x.x[e]=Math.cos(i)*o,x.y[e]=Math.sin(i)*o},an=(t,e)=>{const n=new Map,o=t.count;$.radius.set(t.radius.subarray(0,o),C),Y.strength.set(t.strength.subarray(0,o),C),Y.falloffType.set(t.falloffType.subarray(0,o),C),F.createdAt.set(t.createdAt.subarray(0,o),C),f.x.set(t.posX.subarray(0,o),C),f.y.set(t.posY.subarray(0,o),C),h.parent.set(t.parent.subarray(0,o),C),h.lastCollisionTarget.set(t.lastCollisionTarget.subarray(0,o),C),x.x.set(t.velX.subarray(0,o),C),x.y.set(t.velY.subarray(0,o),C),Z.teleportTarget.set(t.teleportTarget.subarray(0,o),C),Z.exitType.set(t.exitType.subarray(0,o),C);for(let i=0;i<o;i++){const r=t.eid[i],s=dt(e);n.set(r,s),b(e,rt,s),rt.type[s]=t.type[i],rt.cloneOf[s]=r;const c=t.componentTags[i];c&D.AffectedByGravity&&b(e,Rt,s),c&D.Destructible&&b(e,nt,s),c&D.Collision&&b(e,$,s),c&D.HasGravity&&b(e,Y,s),c&D.HasLifetime&&b(e,F,s),c&D.Position&&b(e,f,s),c&D.Projectile&&b(e,h,s),c&D.Velocity&&b(e,x,s),c&D.Wormhole&&b(e,Z,s),c&D.Active&&b(e,M,s)}return n},un=1e4,Kt=8,p=Pe();let wt=new Map,te=[],ee=()=>{};self.onmessage=t=>{const{type:e,snapshot:n,turnInput:o}=t.data;switch(e){case q.INITIALIZE:wt=an(n,p),te=on(p),ee=ln(),self.postMessage({type:q.INITIALIZE_DONE});break;case q.SIMULATE:{const i={...o,playerId:wt.get(o.playerId)},r=yn(i,te,ee),s={...r,hitsEid:rt.cloneOf[r.hitsEid],closestDestructible:rt.cloneOf[r.closestDestructible]};self.postMessage({type:q.SIMULATE_DONE,result:s});break}}},self.postMessage({type:q.ACTIVE});const yn=(t,e,n)=>{const{playerId:o}=t,i=e.filter(S=>S.eid!==o);let r=0,s=0,c=null,a=1/0,u={x:0,y:0};const l=fn(t);for(let S=0;S<un&&(n(p,S,Kt),!!Vt(p,l));S+=Kt){for(const v of i){const R=H(l),{x:_,y:A}=R,g=B(l),{x:y,y:m}=v,G=B(v.eid),lt=y-_,mt=m-A,$t=lt*lt+mt*mt,ne=g+G;if($t<ne*ne){s=v.eid,c=S,v.breaks&&(r=v.eid);break}v.breaks&&$t<a&&(a=$t,r=v.eid,u=R)}if(s){at(p,l);break}}const T=s===r,E=p.movements&&[...p.movements[o].movementTrace]||[];p.movements=null;const P={angle:t.angle,power:t.power},I=!!(s&&z(p,nt,s));return{hitsEid:s,hitsSelf:s===o,destructible:I,willHit:T,closestDestructible:r,closestPoint:u,closestDist2:a,shotDist2:rn(E[0],E[E.length-1]),collisionT:c,input:P,shotTrail:E}},fn=t=>{const e=dt(p),{playerId:n}=t;return b(p,f,e),b(p,x,e),b(p,$,e),b(p,h,e),b(p,Rt,e),b(p,F,e),b(p,M,e),$.radius[e]=2,h.parent[e]=t.playerId,F.createdAt[e]=0,cn(n,e,t),e},ln=()=>{const t=en(),e=sn(),n=we(),o=Xe(),i=Fe(()=>!1),r=Be(s=>at(p,s));return(s,c,a)=>{s.time=c,s.delta=a,t(s),e(s),n(s),o(s),i(s),r(s)}}})();
