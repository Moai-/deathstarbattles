(function(){"use strict";var W={ui8:"ui8",ui16:"ui16",ui32:"ui32",f32:"f32",eid:"eid"},Ot={i8:"Int8",ui8:"Uint8",ui8c:"Uint8Clamped",i16:"Int16",ui16:"Uint16",i32:"Int32",ui32:"Uint32",eid:"Uint32",f32:"Float32",f64:"Float64"},Q={i8:Int8Array,ui8:Uint8Array,ui8c:Uint8ClampedArray,i16:Int16Array,ui16:Uint16Array,i32:Int32Array,ui32:Uint32Array,f32:Float32Array,f64:Float64Array,eid:Uint32Array},Dt={uint8:2**8,uint16:2**16},se=t=>e=>Math.ceil(e/t)*t,re=se(4),oe=Symbol("storeRef"),vt=Symbol("storeSize"),ie=Symbol("storeMaps"),H=Symbol("storeFlattened"),ot=Symbol("storeBase"),ce=Symbol("storeType"),Pt=Symbol("storeArrayElementCounts"),it=Symbol("storeSubarrays"),_t=Symbol("subarrayCursors"),ae=Symbol("subarray"),St=Symbol("parentArray"),jt=Symbol("tagStore"),Lt=Symbol("indexType"),Ut=Symbol("indexBytes"),kt=Symbol("isEidType"),j={},ue=(t,e)=>{if(ArrayBuffer.isView(t))t[e]=t.slice(0);else{const n=t[St].slice(0);t[e]=t.map((o,i)=>{const{length:r}=t[i],s=r*i,c=s+r;return n.subarray(s,c)})}},ye=(t,e)=>{t[H]&&t[H].forEach(n=>{ArrayBuffer.isView(n)?n[e]=0:n[e].fill(0)})},fe=(t,e)=>{const n=e*Q[t].BYTES_PER_ELEMENT,o=new ArrayBuffer(n),i=new Q[t](o);return i[kt]=t===W.eid,i},le=(t,e,n)=>{const o=t[vt],i=Array(o).fill(0);i[ce]=e,i[kt]=e===W.eid;const r=t[_t],s=n<=Dt.uint8?W.ui8:n<=Dt.uint16?W.ui16:W.ui32;if(!n)throw new Error("bitECS - Must define component array length");if(!Q[e])throw new Error(`bitECS - Invalid component array property type ${e}`);if(!t[it][e]){const u=t[Pt][e],l=new Q[e](re(u*o));l[Lt]=Ot[s],l[Ut]=Q[s].BYTES_PER_ELEMENT,t[it][e]=l}const c=r[e],a=c+o*n;r[e]=a,i[St]=t[it][e].subarray(c,a);for(let u=0;u<o;u++){const l=n*u,N=l+n;i[u]=i[St].subarray(l,N),i[u][Lt]=Ot[s],i[u][Ut]=Q[s].BYTES_PER_ELEMENT,i[u][ae]=!0}return i},Bt=t=>Array.isArray(t)&&typeof t[0]=="string"&&typeof t[1]=="number",me=(t,e)=>{const n=Symbol("store");if(!t||!Object.keys(t).length)return j[n]={[vt]:e,[jt]:!0,[ot]:()=>j[n]},j[n];t=JSON.parse(JSON.stringify(t));const o={},i=s=>{const c=Object.keys(s);for(const a of c)Bt(s[a])?(o[s[a][0]]||(o[s[a][0]]=0),o[s[a][0]]+=s[a][1]):s[a]instanceof Object&&i(s[a])};i(t);const r={[vt]:e,[ie]:{},[it]:{},[oe]:n,[_t]:Object.keys(Q).reduce((s,c)=>({...s,[c]:0}),{}),[H]:[],[Pt]:o};if(t instanceof Object&&Object.keys(t).length){const s=(c,a)=>{if(typeof c[a]=="string")c[a]=fe(c[a],e),c[a][ot]=()=>j[n],r[H].push(c[a]);else if(Bt(c[a])){const[u,l]=c[a];c[a]=le(r,u,l),c[a][ot]=()=>j[n],r[H].push(c[a])}else c[a]instanceof Object&&(c[a]=Object.keys(c[a]).reduce(s,c[a]));return c};return j[n]=Object.assign(Object.keys(t).reduce(s,t),r),j[n][ot]=()=>j[n],j[n]}},J=()=>{const t=[],e=[];t.sort=function(s){const c=Array.prototype.sort.call(this,s);for(let a=0;a<t.length;a++)e[t[a]]=a;return c};const n=s=>t[e[s]]===s;return{add:s=>{n(s)||(e[s]=t.push(s)-1)},remove:s=>{if(!n(s))return;const c=e[s],a=t.pop();a!==s&&(t[c]=a,e[a]=c)},has:n,sparse:e,dense:t,reset:()=>{t.length=0,e.length=0}}},U=Symbol("entityMasks"),ct=Symbol("entityComponents"),k=Symbol("entitySparseSet"),K=Symbol("entityArray"),ve=1e5,bt=0,Qt=ve,pt=()=>Qt,w=[],Se=.01,be=Se,pe=()=>bt,de=new Map,dt=t=>{const e=t[Mt]?w.length?w.shift():bt++:w.length>Math.round(Qt*be)?w.shift():bt++;if(e>t[It])throw new Error("bitECS - max entities reached");return t[k].add(e),de.set(e,t),t[ht].forEach(n=>{Et(t,n,e)&&At(n,e)}),t[ct].set(e,new Set),e},at=(t,e)=>{if(t[k].has(e)){t[ut].forEach(n=>{Yt(t,n,e)}),t[Mt]||w.push(e),t[k].remove(e),t[ct].delete(e),t[Gt].delete(t[xt].get(e)),t[xt].delete(e);for(let n=0;n<t[U].length;n++)t[U][n][e]=0}},Ht=(t,e)=>t[k].has(e),he=Symbol("$modifier"),ut=Symbol("queries"),ht=Symbol("notQueries"),Ee=Symbol("queryAny"),Ae=Symbol("queryAll"),ge=Symbol("queryNone"),yt=Symbol("queryMap"),tt=Symbol("$dirtyQueries"),Vt=Symbol("queryComponents"),Ie=(t,e)=>{const n=[],o=[],i=[];e[Vt].forEach(y=>{if(typeof y=="function"&&y[he]){const[m,G]=y();t[L].has(m)||gt(t,m),G==="not"&&o.push(m),G==="changed"&&(i.push(m),n.push(m))}else t[L].has(y)||gt(t,y),n.push(y)});const r=y=>t[L].get(y),s=n.concat(o).map(r),c=J(),a=[],u=[],l=J(),N=J(),E=J(),P=s.map(y=>y.generationId).reduce((y,m)=>(y.includes(m)||y.push(m),y),[]),x=(y,m)=>(y[m.generationId]||(y[m.generationId]=0),y[m.generationId]|=m.bitflag,y),S=n.map(r).reduce(x,{}),v=o.map(r).reduce(x,{}),C=s.reduce(x,{}),_=n.filter(y=>!y[jt]).map(y=>Object.getOwnPropertySymbols(y).includes(H)?y[H]:[y]).reduce((y,m)=>y.concat(m),[]),g=Object.assign(c,{archetypes:a,changed:u,components:n,notComponents:o,changedComponents:i,allComponents:s,masks:S,notMasks:v,hasMasks:C,generations:P,flatProps:_,toRemove:l,entered:N,exited:E,shadows:[]});t[yt].set(e,g),t[ut].add(g),s.forEach(y=>{y.queries.add(g)}),o.length&&t[ht].add(g);for(let y=0;y<pe();y++){if(!t[k].has(y))continue;Et(t,g,y)&&At(g,y)}},xe=(t,e)=>{const n=Symbol(),o=t.flatProps[e];return ue(o,n),t.shadows[e]=o[n],o[n]},Me=(t,e)=>{e&&(t.changed=[]);const{flatProps:n,shadows:o}=t;for(let i=0;i<t.dense.length;i++){const r=t.dense[i];let s=!1;for(let c=0;c<n.length;c++){const a=n[c],u=o[c]||xe(t,c);if(ArrayBuffer.isView(a[r])){for(let l=0;l<a[r].length;l++)if(a[r][l]!==u[r][l]){s=!0;break}u[r].set(a[r])}else a[r]!==u[r]&&(s=!0,u[r]=a[r])}s&&t.changed.push(r)}return t.changed},$=(...t)=>{let e,n,o,i;if(Array.isArray(t[0])&&(e=t[0]),e===void 0||e[L]!==void 0)return s=>s?s[K]:e[K];const r=function(s,c=!0){s[yt].has(r)||Ie(s,r);const a=s[yt].get(r);return Re(s),a.changedComponents.length?Me(a,c):a.dense};return r[Vt]=e,r[Ee]=n,r[Ae]=o,r[ge]=i,r},Et=(t,e,n)=>{const{masks:o,notMasks:i,generations:r}=e;for(let s=0;s<r.length;s++){const c=r[s],a=o[c],u=i[c],l=t[U][c][n];if(u&&(l&u)!==0||a&&(l&a)!==a)return!1}return!0},At=(t,e)=>{t.toRemove.remove(e),t.entered.add(e),t.add(e)},Te=t=>{for(let e=t.toRemove.dense.length-1;e>=0;e--){const n=t.toRemove.dense[e];t.toRemove.remove(n),t.remove(n)}},Re=t=>{t[tt].size&&(t[tt].forEach(Te),t[tt].clear())},Yt=(t,e,n)=>{!e.has(n)||e.toRemove.has(n)||(e.toRemove.add(n),t[tt].add(e),e.exited.add(n))},L=Symbol("componentMap"),M=(t,e)=>{const n=me(t,pt());return t&&Object.keys(t).length,n},Ne=t=>{t[et]*=2,t[et]>=2**31&&(t[et]=1,t[U].push(new Uint32Array(t[It])))},gt=(t,e)=>{if(!e)throw new Error("bitECS - Cannot register null or undefined component");const n=new Set,o=new Set,i=new Set;t[ut].forEach(r=>{r.allComponents.includes(e)&&n.add(r)}),t[L].set(e,{generationId:t[U].length-1,bitflag:t[et],store:e,queries:n,notQueries:o,changedQueries:i}),Ne(t)},z=(t,e,n)=>{const o=t[L].get(e);if(!o)return!1;const{generationId:i,bitflag:r}=o;return(t[U][i][n]&r)===r},b=(t,e,n,o=!1)=>{if(n===void 0)throw new Error("bitECS - entity is undefined.");if(!t[k].has(n))throw new Error("bitECS - entity does not exist in the world.");if(t[L].has(e)||gt(t,e),z(t,e,n))return;const i=t[L].get(e),{generationId:r,bitflag:s,queries:c,notQueries:a}=i;t[U][r][n]|=s,c.forEach(u=>{u.toRemove.remove(n);const l=Et(t,u,n);l&&(u.exited.remove(n),At(u,n)),l||(u.entered.remove(n),Yt(t,u,n))}),t[ct].get(n).add(e),o&&ye(e,n)},It=Symbol("size"),et=Symbol("bitflag"),Ce=Symbol("archetypes"),Gt=Symbol("localEntities"),xt=Symbol("localEntityLookup"),Mt=Symbol("manualEntityRecycling"),$e=(...t)=>{const e=typeof t[0]=="object"?t[0]:{},n=typeof t[0]=="number"?t[0]:typeof t[1]=="number"?t[1]:pt();return Oe(e,n),e},Oe=(t,e=pt())=>(t[It]=e,t[K]&&t[K].forEach(n=>at(t,n)),t[U]=[new Uint32Array(e)],t[ct]=new Map,t[Ce]=[],t[k]=J(),t[K]=t[k].dense,t[et]=1,t[L]=new Map,t[yt]=new Map,t[ut]=new Set,t[ht]=new Set,t[tt]=new Set,t[Gt]=new Map,t[xt]=new Map,t[Mt]=!1,t),X=t=>(e,...n)=>(t(e,...n),e),d=W;const Tt=300,Wt=1920,zt=1080,De=2,ft=0,O=1,Pe=()=>{const t=$e();return t.time=0,t.delta=0,t.movements=null,Ht(t,ft)||dt(t),t};var D=(t=>(t[t.AffectedByGravity=1]="AffectedByGravity",t[t.Collision=2]="Collision",t[t.Destructible=4]="Destructible",t[t.HasGravity=8]="HasGravity",t[t.HasLifetime=16]="HasLifetime",t[t.Position=32]="Position",t[t.Projectile=64]="Projectile",t[t.Velocity=128]="Velocity",t[t.Wormhole=256]="Wormhole",t[t.Active=512]="Active",t))(D||{}),q=(t=>(t[t.ACTIVE=0]="ACTIVE",t[t.INITIALIZE=1]="INITIALIZE",t[t.INITIALIZE_DONE=2]="INITIALIZE_DONE",t[t.SIMULATE=3]="SIMULATE",t[t.SIMULATE_DONE=4]="SIMULATE_DONE",t))(q||{});const Rt=M(),T=M({radius:d.ui16}),nt=M(),V=M({strength:d.f32,radius:d.f32,falloffType:d.ui8});var st=(t=>(t[t.INVERSE_SQUARE=0]="INVERSE_SQUARE",t[t.LINEAR=1]="LINEAR",t[t.CONSTANT=2]="CONSTANT",t))(st||{});const F=M({createdAt:d.ui32}),rt=M({type:d.ui8,cloneOf:d.eid}),_e=M(),f=M({x:d.f32,y:d.f32}),h=M({parent:d.eid,lastCollisionTarget:d.eid}),R=M({x:d.f32,y:d.f32}),Z=M({teleportTarget:d.eid,exitType:d.ui8});var Nt=(t=>(t[t.PAIRED=0]="PAIRED",t[t.RANDOM=1]="RANDOM",t[t.PAIRED_GIANT=2]="PAIRED_GIANT",t))(Nt||{});M({pooledProjectile:d.eid});const I=M(),je=30,Xt=0-Tt,Le=Wt+Tt,Ue=zt+Tt,ke=$([f,R,I]),Be=$([F,I]),Qe=(t=()=>{})=>X(e=>{const n=ke(e);for(const i of n){const r=f.x[i],s=f.y[i];r<Le&&r>Xt&&s<Ue&&s>Xt||t(i)}const o=Be(e);for(const i of o)e.time-F.createdAt[i]>=je*1e3&&t(i);return e}),qt=(t,e)=>Math.floor(Math.random()*(e-t+1)+t),B=t=>T.radius[t],Y=t=>({x:f.x[t],y:f.y[t]}),Ct=(t,e,n)=>{if(typeof e.x<"u"){const o=e;f.x[t]=o.x,f.y[t]=o.y}else f.x[t]=e,f.y[t]=n},He=$([T,f,I]),Ft=t=>He(t);$([T,f,nt,I]);const Ve=t=>Ft(t).map(e=>({x:f.x[e],y:f.y[e],radius:T.radius[e],eid:e}));$([_e,I]);function Ye(t,e,n,o,i){const r=[],s=Array.isArray(i)?i:Ve(i);for(const c of n){let a=0,u=!1;for(;a++<1e3&&!u;){const l=qt(c,t-c),N=qt(c,e-c),E={x:l,y:N,radius:c,eid:-1};[...s,...r].some(x=>{const S=l-x.x,v=N-x.y,C=S*S+v*v,_=o(c,x.radius),A=_*_;return C<A})||(r.push(E),u=!0)}u||(console.log(`Failed to place object with radius ${c} after 1000 attempts.`),r.push({x:10,y:10,radius:c,eid:-1}))}return r}const Ge=(t,e,n,o,i,r)=>{const s=o-t,c=i-e,a=s*s+c*c,u=n+r;return a<u*u},We=(t,e)=>{const{x:n,y:o}=Y(t),i=B(t),{x:r,y:s}=Y(e),c=B(e);return Ge(n,o,i,r,s,c)},ze=$([f,T,h,I]),Xe=$([f,T,I]),qe=()=>X(t=>{const e=ze(t),n=Xe(t);for(let o=0;o<e.length;o++){const i=e[o];for(let r=0;r<n.length;r++){const s=n[r];i!==s&&We(i,s)&&(h.lastCollisionTarget[i]=s)}}return t}),Fe=$([h,f,T,I]),Ze=(t=()=>!0)=>X(e=>{if(!e.movements)return e;const n=Fe(e);for(const o of n){const i=h.parent[o],r=h.lastCollisionTarget[o];if(r!==ft){if(z(e,h,r)){h.lastCollisionTarget[o]=ft;continue}if(z(e,nt,r)){t(o,r,!0,e.time)&&at(e,r),e.movements[i].destroyedTarget=r;continue}if(z(e,Z,r)){Je(o,r,e),h.lastCollisionTarget[o]=ft;continue}t(o,r,!1,e.time)}}return e}),Je=(t,e,n)=>{const o=Z.exitType[e];if(o===Nt.RANDOM){const[A]=Ye(Wt,zt,[B(t)],(g,y)=>g+y+5,n);Ct(t,A);return}const i=Z.teleportTarget[e],r=Y(e),s=Y(i),c=B(i),a=Y(t);if(o===Nt.PAIRED_GIANT){const A=a.x-r.x,g=a.y-r.y,m=Math.atan2(g,A)+Math.PI,G=1.5,lt=s.x+Math.cos(m)*(c+G),mt=s.y+Math.sin(m)*(c+G);Ct(t,lt,mt);return}const u=a.x-r.x,l=a.y-r.y,N=-u,E=-l,P=Math.hypot(N,E),x=N/P,S=E/P,v=1.5,C=s.x+x*(c+v),_=s.y+S*(c+v);Ct(t,C,_)},Zt=1e-4,Ke=$([V,f,I]),we=$([Rt,R,f,I]),tn=()=>X(t=>{const e=t.delta,n=Ke(t),o=we(t);for(const i of o){let r=0,s=0;const c=f.x[i],a=f.y[i];for(const u of n){const l=f.x[u],N=f.y[u],E=l-c,P=N-a,x=E*E+P*P+Zt,S=Math.sqrt(x),v=V.strength[u],C=V.radius[u]||0,_=V.falloffType[u]??st.INVERSE_SQUARE;if(C>0&&S>C)continue;let A=0;switch(_){case st.CONSTANT:A=v;break;case st.LINEAR:if(C>0){const m=1-S/C;A=v*Math.max(0,m)}else A=v/(S+Zt);break;case st.INVERSE_SQUARE:default:A=v/x;break}const g=E/S*A,y=P/S*A;r+=g,s+=y}R.x[i]+=r*e,R.y[i]+=s*e}return t}),Jt=1/300,en=$([f,R,I]),nn=()=>X(t=>{const n=t.delta,o=en(t);for(const i of o){const r=R.x[i],s=R.y[i],c=r*n*Jt,a=s*n*Jt,u=f.x[i]+c,l=f.y[i]+a;f.x[i]=u,f.y[i]=l}return t}),sn=$([f,h,I]),rn=()=>X(t=>{const e=t,n=sn(e);n.length&&(e.movements=e.movements||{});for(const o of n){const i=h.parent[o];e.movements[i]=e.movements[i]||{id:o,movementTrace:[],destroyedTarget:null};const{x:r,y:s}=Y(o);e.movements[i].movementTrace.push({x:r,y:s})}return e}),on=(t,e)=>{const n=t.x-e.x,o=t.y-e.y;return n*n+o*o},cn=t=>Ft(t).map(e=>({eid:e,breaks:z(t,nt,e),x:f.x[e],y:f.y[e],r:B(e),r2:Math.pow(B(e),2)})),an=(t,e,n)=>{const o=n.power*2,i=n.angle*(Math.PI/180),r=T.radius[t]+De;f.x[e]=f.x[t]+Math.cos(i)*r,f.y[e]=f.y[t]+Math.sin(i)*r,R.x[e]=Math.cos(i)*o,R.y[e]=Math.sin(i)*o},un=(t,e)=>{const n=new Map,o=t.count;T.radius.set(t.radius.subarray(0,o),O),V.strength.set(t.strength.subarray(0,o),O),V.falloffType.set(t.falloffType.subarray(0,o),O),F.createdAt.set(t.createdAt.subarray(0,o),O),f.x.set(t.posX.subarray(0,o),O),f.y.set(t.posY.subarray(0,o),O),h.parent.set(t.parent.subarray(0,o),O),h.lastCollisionTarget.set(t.lastCollisionTarget.subarray(0,o),O),R.x.set(t.velX.subarray(0,o),O),R.y.set(t.velY.subarray(0,o),O),Z.teleportTarget.set(t.teleportTarget.subarray(0,o),O),Z.exitType.set(t.exitType.subarray(0,o),O);for(let i=0;i<o;i++){const r=t.eid[i],s=dt(e);n.set(r,s),b(e,rt,s),rt.type[s]=t.type[i],rt.cloneOf[s]=r;const c=t.componentTags[i];c&D.AffectedByGravity&&b(e,Rt,s),c&D.Destructible&&b(e,nt,s),c&D.Collision&&b(e,T,s),c&D.HasGravity&&b(e,V,s),c&D.HasLifetime&&b(e,F,s),c&D.Position&&b(e,f,s),c&D.Projectile&&b(e,h,s),c&D.Velocity&&b(e,R,s),c&D.Wormhole&&b(e,Z,s),c&D.Active&&b(e,I,s)}return n},yn=1e4,Kt=8,p=Pe();let wt=new Map,te=[],ee=()=>{};self.onmessage=t=>{const{type:e,snapshot:n,turnInput:o}=t.data;switch(e){case q.INITIALIZE:wt=un(n,p),te=cn(p),ee=mn(),self.postMessage({type:q.INITIALIZE_DONE});break;case q.SIMULATE:{const i={...o,playerId:wt.get(o.playerId)},r=fn(i,te,ee),s={...r,hitsEid:rt.cloneOf[r.hitsEid],closestDestructible:rt.cloneOf[r.closestDestructible]};self.postMessage({type:q.SIMULATE_DONE,result:s});break}}},self.postMessage({type:q.ACTIVE});const fn=(t,e,n)=>{const{playerId:o}=t,i=e.filter(S=>S.eid!==o);let r=0,s=0,c=null,a=1/0,u={x:0,y:0};const l=ln(t);for(let S=0;S<yn&&(n(p,S,Kt),!!Ht(p,l));S+=Kt){for(const v of i){const C=Y(l),{x:_,y:A}=C,g=B(l),{x:y,y:m}=v,G=B(v.eid),lt=y-_,mt=m-A,$t=lt*lt+mt*mt,ne=g+G;if($t<ne*ne){s=v.eid,c=S,v.breaks&&(r=v.eid);break}v.breaks&&$t<a&&(a=$t,r=v.eid,u=C)}if(s){at(p,l);break}}const N=s===r,E=p.movements&&[...p.movements[o].movementTrace]||[];p.movements=null;const P={angle:t.angle,power:t.power},x=!!(s&&z(p,nt,s));return{hitsEid:s,hitsSelf:s===o,destructible:x,willHit:N,closestDestructible:r,closestPoint:u,closestDist2:a,shotDist2:on(E[0],E[E.length-1]),collisionT:c,input:P,shotTrail:E}},ln=t=>{const e=dt(p),{playerId:n}=t;return b(p,f,e),b(p,R,e),b(p,T,e),b(p,h,e),b(p,Rt,e),b(p,F,e),b(p,I,e),T.radius[e]=T.radius[t.playerId]/8,h.parent[e]=t.playerId,F.createdAt[e]=0,an(n,e,t),e},mn=()=>{const t=nn(),e=rn(),n=tn(),o=qe(),i=Ze(()=>!1),r=Qe(s=>at(p,s));return(s,c,a)=>{s.time=c,s.delta=a,t(s),e(s),n(s),o(s),i(s),r(s)}}})();
